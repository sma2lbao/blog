<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.20.0"/><style data-href="/blog/styles.993139173619a9f6dc9e.css" data-identity="gatsby-global-css">@font-face{font-family:Material Icons;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v139/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format("woff2")}.material-icons{word-wrap:normal;-webkit-font-feature-settings:"liga";-webkit-font-smoothing:antialiased;direction:ltr;display:inline-block;font-family:Material Icons;font-size:24px;font-style:normal;font-weight:400;letter-spacing:normal;line-height:1;text-transform:none;white-space:nowrap}.blog-page img{max-width:100%}code[class*=language-],pre[class*=language-]{word-wrap:normal;color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#073642}pre[class*=language-]{border-radius:.3em;margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{background:#eee8d5;color:#657b83}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 65)
          }), 0)
        }
      }
    })
  </script></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css isbt42">.css-isbt42{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;margin-top:-16px;width:calc(100% + 16px);margin-left:-16px;}.css-isbt42>.MuiGrid-item{padding-top:16px;}.css-isbt42>.MuiGrid-item{padding-left:16px;}</style><div class="MuiGrid-root MuiGrid-container MuiGrid-spacing-xs-2 css-isbt42"><style data-emotion="css 14ybvol">.css-14ybvol{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}@media (min-width:600px){.css-14ybvol{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:900px){.css-14ybvol{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1200px){.css-14ybvol{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1536px){.css-14ybvol{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-9 css-14ybvol"><style data-emotion="css 1vghxu1">.css-1vghxu1{background-color:#fff;color:rgba(0, 0, 0, 0.87);-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:none;padding:16px 32px;margin-top:16px;margin-bottom:16px;}</style><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 blog-page css-1vghxu1"><h2 id="概览" style="position:relative"><a href="#%E6%A6%82%E8%A7%88" aria-label="概览 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h2><p>HTTP 缓存存储与请求关联的响应，并将存储的响应复用于后续请求。</p><p>可复用性有几个优点。首先，由于不需要将请求传递到源服务器，因此客户端和缓存越近，响应速度就越快。最典型的例子是浏览器本身为浏览器请求存储缓存。</p><p>此外，当响应可复用时，源服务器不需要处理请求——因为它不需要解析和路由请求、根据 cookie 恢复会话、查询数据库以获取结果或渲染模板引擎。这减少了服务器上的负载。</p><p>缓存的正确操作对系统的稳定运行至关重要。</p><h2 id="不同种类的缓存" style="position:relative"><a href="#%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98" aria-label="不同种类的缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不同种类的缓存</h2><p>在 <a href="https://httpwg.org/specs/rfc9111.html">HTTP Caching</a> 标准中, 有两种不同类型的缓存：<strong>私有缓存</strong>和<strong>共享缓存</strong>。</p><h3 id="私有缓存" style="position:relative"><a href="#%E7%A7%81%E6%9C%89%E7%BC%93%E5%AD%98" aria-label="私有缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>私有缓存</h3><p>私有缓存是绑定到特定客户端的缓存——通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。</p><p>另一方面，如果个性化内容存储在私有缓存以外的缓存中，那么其他用户可能能够检索到这些内容——这可能会导致无意的信息泄露。</p><p>如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 <code class="language-text">private</code> 指令。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">private</span></span></code></pre></div><p>个性化内容通常由 cookie 控制，但 cookie 的存在并不能表明它是私有的，因此单独的 cookie 不会使响应成为私有的。</p><p>请注意，如果响应具有 <code class="language-text">Authorization</code> 标头，则不能将其存储在私有缓存（或共享缓存，除非指定了 <code class="language-text">public</code> ）中。</p><h3 id="共享缓存" style="position:relative"><a href="#%E5%85%B1%E4%BA%AB%E7%BC%93%E5%AD%98" aria-label="共享缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>共享缓存</h3><p>共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为<strong>代理缓存</strong>和<strong>托管缓存</strong>。</p><h4 id="代理缓存" style="position:relative"><a href="#%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98" aria-label="代理缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代理缓存</h4><p>除了访问控制的功能外，一些代理还实现了缓存以减少网络流量。这通常不由服务开发人员管理，因此必须由恰当的 HTTP 标头等控制。然而，在过去，过时的代理缓存实现——例如没有正确理解 HTTP 缓存标准的实现——经常给开发人员带来问题。</p><p><strong>Kitchen-sink 标头</strong>如下所示，用于尝试解决不理解当前 HTTP 缓存规范指令（如 <code class="language-text">no-store</code>）的“旧且未更新的代理缓存”的实现。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate</span></span></code></pre></div><p>然而，近年来，随着 HTTPS 变得越来越普遍，客户端/服务器通信变得加密，在许多情况下，路径中的代理缓存只能传输响应而不能充当缓存。因此，在这种情况下，无需担心甚至无法看到响应的过时代理缓存的实现。</p><p>另一方面，如果 TLS 桥接代理通过在 PC 上安装来自组织管理的 CA 证书，以中间人方式解密所有通信，并执行访问控制等，则可以查看响应的内容并将其缓存。但是，由于证书透明度在最近几年变得很普遍，并且一些浏览器只允许使用证书签署时间戳（signed certificate timestamp）颁发的证书，因此这种方法需要应用于企业策略。在这样的受控环境中，无需担心代理缓存“已过时且未更新”。</p><h4 id="托管缓存" style="position:relative"><a href="#%E6%89%98%E7%AE%A1%E7%BC%93%E5%AD%98" aria-label="托管缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>托管缓存</h4><p>托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。示例包括反向代理、CDN 和 service worker 与缓存 API 的组合。</p><p>托管缓存的特性因部署的产品而异。在大多数情况下，你可以通过 <code class="language-text">Cache-Control</code> 标头和你自己的配置文件或仪表板来控制缓存的行为。</p><p>例如，HTTP 缓存规范本质上没有定义显式删除缓存的方法——但是使用托管缓存，可以通过仪表板操作、API 调用、重新启动等实时删除已经存储的响应。这允许更主动的缓存策略。</p><p>也可以忽略标准 HTTP 缓存规范协议以支持显式操作。例如，可以指定以下内容以选择退出私有缓存或代理缓存，同时使用你自己的策略仅在托管缓存中进行缓存。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-store</span></span></code></pre></div><p>例如，Varnish Cache 使用 VCL（Varnish Configuration Language，一种 DSL 逻辑来处理缓存存储，而 service worker 结合缓存 API 允许你在 JavaScript 中创建该逻辑。</p><p>这意味着如果托管缓存故意忽略 <code class="language-text">no-store</code> 指令，则无需将其视为“不符合”标准。你应该做的是，避免使用 kitchen-sink 标头，但仔细阅读你正在使用的任何托管缓存机制的文档，并确保你选择的方式可以正确的控制缓存。</p><p>请注意，某些 CDN 提供自己的标头，这些标头仅对该 CDN 有效（例如，<code class="language-text">Surrogate-Control</code>）。目前，正在努力定义一个 <a href="https://httpwg.org/specs/rfc9213.html"><code class="language-text">CDN-Cache-Control</code></a> 标头来标准化这些标头。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching/type-of-cache.png" alt="Type of Cache"/></p><h2 id="启发式缓存" style="position:relative"><a href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E7%BC%93%E5%AD%98" aria-label="启发式缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>启发式缓存</h2><p>HTTP 旨在尽可能多地缓存，因此即使没有给出 <code class="language-text">Cache-Control</code>，如果满足某些条件，响应也会被存储和重用。这称为<strong>启发式缓存</strong>。</p><p>例如，采取以下响应。此回复最后一次更新是在 1 年前。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2021 22:22:22 GMT</span></span>
<span class="token text-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>试探性地知道，整整一年没有更新的内容在那之后的一段时间内不会更新。因此，客户端存储此响应（尽管缺少 <code class="language-text">max-age</code>）并重用它一段时间。复用多长时间取决于实现，但规范建议存储后大约 10%（在本例中为 0.1 年）的时间。</p><p>启发式缓存是在 <code class="language-text">Cache-Control</code> 被广泛采用之前出现的一种解决方法，基本上所有响应都应明确指定 <code class="language-text">Cache-Control</code> 标头。</p><h2 id="基于-age-的缓存策略" style="position:relative"><a href="#%E5%9F%BA%E4%BA%8E-age-%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" aria-label="基于 age 的缓存策略 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 age 的缓存策略</h2><p>存储的 HTTP 响应有两种状态：<strong>fresh</strong> 和 <strong>stale</strong>。<em>fresh</em> 状态通常表示响应仍然有效，可以重复使用，而 <em>stale</em> 状态表示缓存的响应已经过期。</p><p>确定响应何时是 fresh 的和何时是 stale 的标准是 <strong>age</strong> 。在 HTTP 中，age 是自响应生成以来经过的时间。这类似于其他缓存机制中的 TTL。</p><p>以下面的示例响应为例（604800 秒是一周）：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=604800</span></span>
<span class="token text-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>存储示例响应的缓存计算响应生成后经过的时间，并将结果用作响应的 <em>age</em> 。</p><p>对于示例响应，<code class="language-text">max-age</code> 的含义如下：</p><ul><li>如果响应的 age <em>小于</em>一周，则响应为 <em>fresh</em>。</li><li>如果响应的 age <em>超过</em>一周，则响应为 <em>stale</em>。</li></ul><p>只要存储的响应保持新鲜（fresh）  ，它将用于兑现客户端请求。</p><p>当响应存储在共享缓存中时，有必要通知客户端响应的 age。继续看示例，如果共享缓存将响应存储了一天，则共享缓存将向后续客户端请求发送以下响应。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=604800</span></span>
<span class="token header"><span class="token header-name keyword">Age</span><span class="token punctuation">:</span> <span class="token header-value">86400</span></span>
<span class="token text-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>收到该响应的客户端会发现它在剩余的 518400 秒内是新鲜（fresh）的，这是响应的 <code class="language-text">max-age</code> 和 <code class="language-text">Age</code> 之间的差异。</p><h2 id="expires-或-max-age" style="position:relative"><a href="#expires-%E6%88%96-max-age" aria-label="expires 或 max age permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires 或 max-age</h2><p>在 HTTP/1.0 中，新鲜度过去由 <code class="language-text">Expires</code> 标头指定。</p><p><code class="language-text">Expires</code> 标头使用明确的时间而不是通过指定经过的时间来指定缓存的生命周期。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 28 Feb 2022 22:22:22 GMT</span></span></code></pre></div><p>但是时间格式难以解析，也发现了很多实现的错误，有可能通过故意偏移系统时钟来诱发问题；因此，在 HTTP/1.1 中，<code class="language-text">Cache-Control</code> 采用了 <code class="language-text">max-age</code>——用于指定经过的时间。</p><p>如果 <code class="language-text">Expires</code> 和 <code class="language-text">Cache-Control: max-age</code> 都可用，则将 <code class="language-text">max-age</code> 定义为首选。因此，由于 HTTP/1.1 已被广泛使用，无需特地提供 <code class="language-text">Expires</code>。</p><h2 id="vary-响应" style="position:relative"><a href="#vary-%E5%93%8D%E5%BA%94" aria-label="vary 响应 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vary 响应</h2><p>区分响应的方式本质上是基于它们的 URL：</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching/keyed-with-url.png" alt="keyed with url"/></p><p>但是响应的内容并不总是相同的，即使它们具有相同的 URL。特别是在执行内容协商时，来自服务器的响应可能取决于 <code class="language-text">Accept</code>、<code class="language-text">Accept-Language</code> 和 <code class="language-text">Accept-Encoding</code> 请求标头的值。</p><p>例如，对于带有 <code class="language-text">Accept-Language: en</code> 标头并已缓存的英语内容，不希望再对具有 <code class="language-text">Accept-Language: ja</code> 请求标头的请求重用该缓存响应。在这种情况下，您可以通过在 <code class="language-text">Vary</code> 标头的值中添加 “<code class="language-text">Accept-Language</code>”，根据语言单独缓存响应。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Vary</span><span class="token punctuation">:</span> <span class="token header-value">Accept-Language</span></span></code></pre></div><p>这会导致缓存基于响应 URL 和 <code class="language-text">Accept-Language</code>请求标头的组合进行键控——而不是仅仅基于响应 URL。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching/keyed-with-url-and-language.png" alt="keyed with url and language"/></p><p>此外，如果你基于用户代理提供内容优化（例如，响应式设计），你可能会想在 <code class="language-text">Vary</code> 标头的值中包含 “<code class="language-text">User-Agent</code>”。但是，<code class="language-text">User-Agent</code> 请求标头通常具有非常多的变体，这大大降低了缓存被重用的机会。因此，如果可能，请考虑一种基于特征检测而不是基于 <code class="language-text">User-Agent</code> 请求标头来改变行为的方法。</p><p>对于使用 cookie 来防止其他人重复使用缓存的个性化内容的应用程序，你应该指定 <code class="language-text">Cache-Control: private</code> 而不是为 <code class="language-text">Vary</code> 指定 cookie。</p><h2 id="验证响应" style="position:relative"><a href="#%E9%AA%8C%E8%AF%81%E5%93%8D%E5%BA%94" aria-label="验证响应 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>验证响应</h2><p>过时的响应不会立即被丢弃。 HTTP 有一种机制，可以通过询问源服务器将陈旧的响应转换为新的响应。这称为<strong>验证</strong>，有时也称为<strong>重新验证</strong>。</p><p>验证是通过使用包含 <code class="language-text">If-Modified-Since</code> 或 <code class="language-text">If-None-Match</code> 请求标头的<strong>条件请求</strong>完成的。</p><h3 id="if-modified-since" style="position:relative"><a href="#if-modified-since" aria-label="if modified since permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>If-Modified-Since</h3><p>以下响应在 22:22:22 生成，<code class="language-text">max-age</code> 为 1 小时，因此你知道它在 23:22:22 之前是新鲜的。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:00:00 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600</span></span>
<span class="token text-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>如果内容自指定时间以来没有更改，服务器将响应 <code class="language-text">304 Not Modified</code>。</p><p>由于此响应仅表示“没有变化”，因此没有响应主体——只有一个状态码——因此传输大小非常小。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">304</span> <span class="token reason-phrase string">Not Modified</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 23:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:00:00 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600</span></span></code></pre></div><p>收到该响应后，客户端将存储的陈旧响应恢复为新鲜的，并可以在剩余的 1 小时内重复使用它。</p><p>服务器可以从操作系统的文件系统中获取修改时间，这对于提供静态文件的情况来说是比较容易做到的。但是，也存在一些问题；例如，时间格式复杂且难以解析，分布式服务器难以同步文件更新时间。</p><p>为了解决这些问题，<code class="language-text">ETag</code> 响应标头被标准化作为替代方案。</p><h3 id="etagif-none-match" style="position:relative"><a href="#etagif-none-match" aria-label="etagif none match permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETag/If-None-Match</h3><p><code class="language-text">ETag</code> 响应头的值是服务器生成的任意值。服务器对于生成值没有任何限制，因此服务器可以根据他们选择的任何方式自由设置值 - 例如正文内容的哈希或版本号。</p><p>举个例子，如果 <code class="language-text">ETag</code> 头使用了 hash 值，<code class="language-text">index.html</code> 资源的 hash 值是 <code class="language-text">deadbeef</code>，响应如下：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">&quot;deadbeef&quot;</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600</span></span>
<span class="token text-html">
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>如果该响应是陈旧的，则客户端获取缓存响应的 <code class="language-text">ETag</code> 响应标头的值，并将其放入 <code class="language-text">If-None-Match</code> 请求标头中，以询问服务器资源是否已被修改：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/index.html</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">example.com</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">If-None-Match</span><span class="token punctuation">:</span> <span class="token header-value">&quot;deadbeef&quot;</span></span></code></pre></div><p>如果服务器为请求的资源确定的 <code class="language-text">ETag</code> 标头的值与请求中的 <code class="language-text">If-None-Match</code> 值相同，则服务器将返回 <code class="language-text">304 Not Modified</code>。</p><p>但是，如果服务器确定请求的资源现在应该具有不同的 <code class="language-text">ETag</code> 值，则服务器将其改为 <code class="language-text">200 OK</code> 和资源的最新版本进行响应。</p><blockquote><p><strong>备注：</strong> 在评估如何使用 <code class="language-text">ETag</code> 和 <code class="language-text">Last-Modified</code> 时，请考虑以下几点：在缓存重新验证期间，如果 <code class="language-text">ETag</code> 和 <code class="language-text">Last-Modified</code> 都存在，则 <code class="language-text">ETag</code> 优先。因此，如果你只考虑缓存，你可能会认为 <code class="language-text">Last-Modified</code> 是不必要的。然而，<code class="language-text">Last-Modified</code> 不仅仅对缓存有用；相反，它是一个标准的 HTTP 标头，内容管理 (CMS) 系统也使用它来显示上次修改时间，由爬虫调整爬取频率，以及用于其他各种目的。所以考虑到整个 HTTP 生态系统，最好同时提供 <code class="language-text">ETag</code> 和 <code class="language-text">Last-Modified</code>。</p></blockquote><h3 id="强制重新验证" style="position:relative"><a href="#%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81" aria-label="强制重新验证 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强制重新验证</h3><p>如果你不希望重复使用响应，而是希望始终从服务器获取最新内容，则可以使用 <code class="language-text">no-cache</code> 指令强制验证。</p><p>通过在响应中添加 <code class="language-text">Cache-Control: no-cache</code> 以及 <code class="language-text">Last-Modified</code> 和 <code class="language-text">ETag</code> - 如下所示 - 如果请求的资源已更新，客户端将收到 <code class="language-text">200 OK</code> 响应，否则，如果请求的资源尚未更新，则会收到 <code class="language-text">304 Not Modified</code> 响应。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:22:22 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 22:00:00 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">deadbeef</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span>
<span class="token text-html">
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p><code class="language-text">max-age=0</code> 和 <code class="language-text">must-revalidate</code> 的组合与 <code class="language-text">no-cache</code> 具有相同的含义。</p><div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Cache-Control: max-age=0, must-revalidate</code></pre></div><p><code class="language-text">max-age=0</code> 意味着响应立即过时，而 <code class="language-text">must-revalidate</code> 意味着一旦过时就不得在没有重新验证的情况下重用它——因此，结合起来，语义似乎与 <code class="language-text">no-cache</code> 相同。</p><p>然而，<code class="language-text">max-age=0</code> 的使用是解决 HTTP/1.1 之前的许多实现无法处理 <code class="language-text">no-cache</code> 这一指令——因此为了解决这个限制，<code class="language-text">max-age=0</code> 被用作解决方法。</p><p>但是现在符合 HTTP/1.1 的服务器已经广泛部署，没有理由使用 <code class="language-text">max-age=0</code> 和 <code class="language-text">must-revalidate</code> 组合——你应该只使用 <code class="language-text">no-cache</code>。</p><h2 id="不使用缓存" style="position:relative"><a href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98" aria-label="不使用缓存 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不使用缓存</h2><p><code class="language-text">no-cache</code> 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。</p><p>如果你不希望将响应存储在任何缓存中，请使用 <code class="language-text">no-store</code>。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-store</span></span></code></pre></div><p>但是，一般来说，实践中“不缓存”的原因满足以下情况：</p><ul><li>出于隐私原因，不希望特定客户以外的任何人存储响应。</li><li>希望始终提供最新信息。</li><li>不知道在过时的实现中会发生什么。</li></ul><p>在这种情况下，<code class="language-text">no-store</code> 并不总是最合适的指令。</p><p>以下部分更详细地介绍了这些情况。</p><h3 id="不与其他用户共享" style="position:relative"><a href="#%E4%B8%8D%E4%B8%8E%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%85%B1%E4%BA%AB" aria-label="不与其他用户共享 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不与其他用户共享</h3><p>如果具有个性化内容的响应意外地对缓存的其他用户可见，那将是有问题的。</p><p>在这种情况下，使用 <code class="language-text">private</code> 指令将导致个性化响应仅与特定客户端一起存储，而不会泄露给缓存的任何其他用户。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">private</span></span></code></pre></div><p>在这种情况下，即使设置了 <code class="language-text">no-store</code>，也必须设置 <code class="language-text">private</code>。</p><h3 id="每次都提供最新的内容" style="position:relative"><a href="#%E6%AF%8F%E6%AC%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%80%E6%96%B0%E7%9A%84%E5%86%85%E5%AE%B9" aria-label="每次都提供最新的内容 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>每次都提供最新的内容</h3><p><code class="language-text">no-store</code> 指令阻止存储响应，但不会删除相同 URL 的任何已存储响应。</p><p>换句话说，如果已经为特定 URL 存储了旧响应，则返回 <code class="language-text">no-store</code> 不会阻止旧响应被重用。</p><p>但是，<code class="language-text">no-cache</code> 指令将强制客户端在重用任何存储的响应之前发送验证请求。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span></code></pre></div><p>如果服务端不支持条件请求，你可以强制客户端每次都访问服务端，总是得到最新的 200 OK 响应。</p><h3 id="兼容过时的实现" style="position:relative"><a href="#%E5%85%BC%E5%AE%B9%E8%BF%87%E6%97%B6%E7%9A%84%E5%AE%9E%E7%8E%B0" aria-label="兼容过时的实现 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>兼容过时的实现</h3><p>作为忽略 <code class="language-text">no-store</code> 的过时实现的解决方法，你可能会看到使用了诸如以下内容的 kitchen-sink 标头：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate</span></span></code></pre></div><p><a href="https://docs.microsoft.com/en-us/troubleshoot/developer/browsers/connectivity-navigation/how-to-prevent-caching">推荐</a>使用 <code class="language-text">no-cache</code> 作为处理这种过时的实现的替代方案，如果从一开始就设置 <code class="language-text">no-cache</code> 就没问题，因为服务器总是会收到请求。</p><p>如果你关心的是共享缓存，你可以通过添加 <code class="language-text">private</code> 来防止意外缓存：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache, private</span></span></code></pre></div><h3 id="no-store-丢失了什么" style="position:relative"><a href="#no-store-%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BB%80%E4%B9%88" aria-label="no store 丢失了什么 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">no-store</code> 丢失了什么</h3><p>你可能认为添加 <code class="language-text">no-store</code> 是选择退出缓存的正确方法。</p><p>但是，不建议随意授予 <code class="language-text">no-store</code>，因为你失去了 HTTP 和浏览器所拥有的许多优势，包括浏览器的后退/前进缓存。</p><p>因此，要获得 Web 平台的全部功能集的优势，最好将 <code class="language-text">no-cache</code> 与 <code class="language-text">private</code> 结合使用。</p><h2 id="重新加载和强制重新加载" style="position:relative"><a href="#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD" aria-label="重新加载和强制重新加载 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重新加载和强制重新加载</h2><p>可以对请求和响应执行验证。</p><p><strong>重新加载</strong>和<strong>强制重新加载</strong>操作是从浏览器端执行验证的常见示例。</p><h3 id="重新加载" style="position:relative"><a href="#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD" aria-label="重新加载 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重新加载</h3><p>为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。</p><p>在浏览器重新加载期间发送的 HTTP 请求的简化视图如下所示：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">example.com</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=0</span></span>
<span class="token header"><span class="token header-name keyword">If-None-Match</span><span class="token punctuation">:</span> <span class="token header-value">&quot;deadbeef&quot;</span></span>
<span class="token header"><span class="token header-name keyword">If-Modified-Since</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 20:20:20 GMT</span></span></code></pre></div><p>（来自 Chrome、Edge 和 Firefox 的请求看起来很像上面的；来自 Safari 的请求看起来会有点不同。）</p><p>请求中的 <code class="language-text">max-age=0</code> 指令指定“重用 age 为 0 或更少的响应”——因此，中间存储的响应不会被重用。</p><p>请求通过 <code class="language-text">If-None-Match</code> 和 <code class="language-text">If-Modified-Since</code> 进行验证。</p><p>该行为也在 <a href="https://fetch.spec.whatwg.org/#http-network-or-cache-fetch">Fetch</a> 标准中定义，并且可以通过将缓存模式设置为 <code class="language-text">no-cache</code>（注意 <code class="language-text">reload</code> 不是这种情况下的正确模式）：</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 注意：“reload”不是正常重新加载的正确模式；“no-cache”才是</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#x27;/&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">cache</span><span class="token operator">:</span> <span class="token string">&#x27;no-cache&#x27;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><h3 id="强制重新加载" style="position:relative"><a href="#%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD" aria-label="强制重新加载 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强制重新加载</h3><p>出于向后兼容的原因，浏览器在重新加载期间使用 <code class="language-text">max-age=0</code>——因为在 HTTP/1.1 之前的许多过时的实现中不理解 <code class="language-text">no-cache</code>。但是在这个用例中，<code class="language-text">no-cache</code> 已被支持，并且<strong>强制重新加载</strong>是绕过缓存响应的另一种方法。</p><p>浏览器<strong>强制重新加载</strong>期间的 HTTP 请求如下所示：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">example.com</span></span>
<span class="token header"><span class="token header-name keyword">Pragma</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span></code></pre></div><p>（来自 Chrome、Edge 和 Firefox 的请求看起来很像上面的；来自 Safari 的请求看起来会有点不同。）</p><p>由于这不是带有 <code class="language-text">no-cache</code> 的条件请求，因此你可以确定你会从源服务器获得 <code class="language-text">200 OK</code>。</p><p>该行为也在 <a href="https://fetch.spec.whatwg.org/#http-network-or-cache-fetch">Fetch</a> 标准中定义，并且可以通过使用缓存模式设置为 <code class="language-text">reload</code>（注意它不是<code class="language-text">force-reload</code>）：</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 注意：“reload”——而不是 “no-cache”——是 “强制重新加载” 的正确模式</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#x27;/&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">cache</span><span class="token operator">:</span> <span class="token string">&#x27;reload&#x27;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><h3 id="避免重新验证" style="position:relative"><a href="#%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81" aria-label="避免重新验证 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免重新验证</h3><p>永远不会改变的内容应该被赋予一个较长的 <code class="language-text">max-age</code>，方法是使用缓存破坏——也就是说，在请求 URL 中包含版本号、哈希值等。</p><p>但是，当用户重新加载时，即使服务器知道内容是不可变的，也会发送重新验证请求。</p><p>为了防止这种情况，<code class="language-text">immutable</code> 指令可用于明确指示不需要重新验证，因为内容永远不会改变。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=31536000, immutable</span></span></code></pre></div><p>这可以防止在重新加载期间进行不必要的重新验证。</p><p>请注意，<a href="https://blog.chromium.org/2017/01/reload-reloaded-faster-and-leaner-page_26.html">Chrome 已更改其实现</a>而不是实现该指令，因此重新验证不是在重新加载子资源期间执行。</p><h2 id="删除存储的响应" style="position:relative"><a href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E7%9A%84%E5%93%8D%E5%BA%94" aria-label="删除存储的响应 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除存储的响应</h2><p>基本上没有办法删除用很长的 <code class="language-text">max-age</code> 存储的响应。</p><p>想象一下，来自 <code class="language-text">https://example.com/</code> 的以下响应已被存储。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=31536000</span></span>
<span class="token text-html">
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
…</span></code></pre></div><p>一旦响应在服务器上过期，您可能希望覆盖该响应，但是一旦存储响应，服务器就无法执行任何操作——因为由于缓存，不再有请求到达服务器。</p><p>规范中提到的方法之一是使用不安全的方法（例如 POST）发送对同一 URL 的请求，但对于许多客户端而言，通常很难故意这样做。</p><p>还有一个 <code class="language-text">Clear-Site-Data: cache</code> 标头和值的规范，但<a href="https://groups.google.com/a/mozilla.org/g/dev-platform/c/I939w1yrTp4">并非所有浏览器都支持它</a>——即使使用它，它也只会影响浏览器缓存，而不会影响中间缓存。</p><p>因此，除非用户手动执行重新加载、强制重新加载或清除历史操作，否则应该假设任何存储的响应都将保留其 <code class="language-text">max-age</code> 期间。</p><p>缓存减少了对服务器的访问，这意味着服务器失去了对该 URL 的控制。如果服务器不想失去对 URL 的控制——例如，在资源被频繁更新的情况下——你应该添加 <code class="language-text">no-cache</code>，以便服务器始终接收请求并发送预期的响应。</p><h2 id="请求折叠" style="position:relative"><a href="#%E8%AF%B7%E6%B1%82%E6%8A%98%E5%8F%A0" aria-label="请求折叠 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>请求折叠</h2><p>共享缓存主要位于源服务器之前，旨在减少到源服务器的流量。</p><p>因此，如果多个相同的请求同时到达共享缓存，中间缓存将代表自己将单个请求转发到源，然后源可以将结果重用于所有客户端。这称为<strong><em>请求折叠</em></strong>。</p><p>当请求同时到达时会发生请求折叠，因此即使响应中给出了 <code class="language-text">max-age=0</code> 或 <code class="language-text">no-cache</code>，它也会被重用。</p><p>如果响应是针对特定用户个性化的，并且你不希望它在折叠中共享，则应添加 <code class="language-text">private</code> 指令：</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching/request-collapse.png" alt="Request Collapse"/></p><h2 id="常见的缓存模式" style="position:relative"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F" aria-label="常见的缓存模式 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>常见的缓存模式</h2><p><code class="language-text">Cache-Control</code> 规范中有很多指令，可能很难全部理解。但是大多数网站都可以通过几种模式的组合来覆盖。</p><p>本节介绍设计缓存的常见模式。</p><h3 id="默认设置" style="position:relative"><a href="#%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE" aria-label="默认设置 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认设置</h3><p>如上所述，缓存的默认行为（即对于没有 <code class="language-text">Cache-Control</code> 的响应）不仅仅是“不缓存”，而是根据所谓的“启发式缓存”进行隐式缓存。</p><p>为了避免这种启发式缓存，最好显式地为所有响应提供一个默认的 <code class="language-text">Cache-Control</code> 标头。</p><p>为确保默认情况下始终传输最新版本的资源，通常的做法是让默认的 <code class="language-text">Cache-Control</code> 值包含 <code class="language-text">no-cache</code>：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span></code></pre></div><p>另外，如果服务实现了 cookie 或其他登录方式，并且内容是为每个用户个性化的，那么也必须提供 <code class="language-text">private</code>，以防止与其他用户共享：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache, private</span></span></code></pre></div><h3 id="缓存破坏" style="position:relative"><a href="#%E7%BC%93%E5%AD%98%E7%A0%B4%E5%9D%8F" aria-label="缓存破坏 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存破坏</h3><p>最适合缓存的资源是静态不可变文件，其内容永远不会改变。而对于会变化的资源，通常的最佳实践是每次内容变化时都改变 URL，这样 URL 单元可以被缓存更长的时间。</p><p>例如，考虑以下 HTML：</p><div class="gatsby-highlight" data-language="html"><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bundle.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>build.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  hello
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre></div><p>在现代 Web 开发中，JavaScript 和 CSS 资源会随着开发的进展而频繁更新。此外，如果客户端使用的 JavaScript 和 CSS 资源的版本不同步，则显示将中断。</p><p>所以上面的 HTML 用 <code class="language-text">max-age</code> 缓存 <code class="language-text">bundle.js</code> 和 <code class="language-text">build.css</code> 变得很困难。</p><p>因此，你可以使用包含基于版本号或哈希值的更改部分的 URL 来提供 JavaScript 和 CSS。一些方法如下所示。</p><div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"># version in filename
bundle.v123.js

# version in query
bundle.js?v=123

# hash in filename
bundle.YsAIAAAA-QG4G6kCMAMBAAAAAAAoK.js

# hash in query
bundle.js?v=YsAIAAAA-QG4G6kCMAMBAAAAAAAoK</code></pre></div><p>由于缓存根据它们的 URL 来区分资源，因此如果在更新资源时 URL 发生变化，缓存将不会再次被重用。</p><div class="gatsby-highlight" data-language="html"><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bundle.v123.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>build.v123.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  hello
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre></div><p>通过这种设计，JavaScript 和 CSS 资源都可以被缓存很长时间。那么 <code class="language-text">max-age</code> 应该设置多长时间呢？ QPACK 规范提供了该问题的答案。</p><p><a href="https://datatracker.ietf.org/doc/html/rfc9204">QPACK</a> 是一种用于压缩 HTTP 标头字段的标准，其中定义了常用字段值表。</p><p>一些常用的缓存头值如下所示。</p><div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">36 cache-control max-age=0
37 cache-control max-age=2592000
38 cache-control max-age=604800
39 cache-control no-cache
40 cache-control no-store
41 cache-control public, max-age=31536000</code></pre></div><p>如果你选择其中一个编号选项，则可以在通过 HTTP3 传输时将值压缩为 1 个字节。</p><p>数字 “37”、“38” 和 “41” 分别代表一周、一个月和一年。</p><p>因为缓存会在保存新条目时删除旧条目，所以一周后存储的响应仍然存在的可能性并不高——即使 <code class="language-text">max-age</code> 设置为 1 周。因此，在实践中，你选择哪一种并没有太大的区别。</p><p>请注意，数字 “41” 具有最长的 <code class="language-text">max-age</code>（1 年），但具有 <code class="language-text">public</code>。</p><p><code class="language-text">public</code> 值具有使响应可存储的效果，即使存在 <code class="language-text">Authorization</code> 标头。</p><blockquote><p><strong>备注：</strong> 只有在设置了 <code class="language-text">Authorization</code> 标头时需要存储响应时才应使用 <code class="language-text">public</code> 指令。否则不需要，因为只要给出了 <code class="language-text">max-age</code>，响应就会存储在共享缓存中。</p></blockquote><p>因此，如果响应是使用基本身份验证进行个性化的，<code class="language-text">public</code> 的存在可能会导致问题。如果您对此感到担忧，您可以选择第二长的值 “37”（1 个月）。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"># response for bundle.v123.js

# If you never personalize responses via Authorization
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public, max-age=31536000</span></span>

# If you can&#x27;t be certain
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=2592000</span></span></code></pre></div><h3 id="验证响应-1" style="position:relative"><a href="#%E9%AA%8C%E8%AF%81%E5%93%8D%E5%BA%94-1" aria-label="验证响应 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>验证响应</h3><p>不要忘记设置 <code class="language-text">Last-Modified</code> 和 <code class="language-text">ETag</code> 标头，以便在重新加载时不必重新传输资源。为预构建的静态文件生成这些标头很容易。</p><p>这里的 <code class="language-text">ETag</code> 值可能是文件的哈希值。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"># response for bundle.v123.js
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 20:20:20 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">YsAIAAAA-QG4G6kCMAMBAAAAAAAoK</span></span></code></pre></div><p>此外，可以添加 <code class="language-text">immutable</code> 以防止重新加载时验证。</p><p>组合结果如下所示。</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"># bundle.v123.js
200 OK HTTP/1.1
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">application/javascript</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public, max-age=31536000, immutable</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 20:20:20 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">YsAIAAAA-QG4G6kCMAMBAAAAAAAoK</span></span></code></pre></div><p><strong>缓存破坏</strong>是一种通过在内容更改时更改 URL 来使响应在很长一段时间内可缓存的技术。该技术可以应用于所有子资源，例如图像。</p><blockquote><p><strong>备注：</strong> 在评估 <code class="language-text">immutable</code> 和 QPACK 的使用时：如果你担心 <code class="language-text">immutable</code> 会更改 QPACK 提供的预定义值，请考虑在这种情况下，<code class="language-text">immutable</code> 部分可以通过将 <code class="language-text">Cache-Control</code> 值分成两行来单独编码——尽管这取决于特定 QPACK 实现使用的编码算法。</p></blockquote><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public, max-age=31536000</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">immutable</span></span></code></pre></div><h3 id="主要资源" style="position:relative"><a href="#%E4%B8%BB%E8%A6%81%E8%B5%84%E6%BA%90" aria-label="主要资源 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主要资源</h3><p>与 子资源不同，主资源不能使用缓存破坏，因为它们的 URL 不能像子资源 URL 一样被修饰。</p><p>如果存储以下 HTML 本身，即使在服务器端更新内容，也无法显示最新版本。</p><div class="gatsby-highlight" data-language="html"><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bundle.v123.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>build.v123.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  hello
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre></div><p>对于这种情况，<code class="language-text">no-cache</code> 将是合适的——而不是 <code class="language-text">no-store</code>——因为我们不想存储 HTML，而只是希望它始终是最新的。</p><p>此外，添加 <code class="language-text">Last-Modified</code> 和 <code class="language-text">ETag</code> 将允许客户端发送条件请求，如果 HTML 没有更新，则可以返回 <code class="language-text">304 Not Modified</code>：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http">200 OK HTTP/1.1
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 20:20:20 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">AAPuIbAOdvAGEETbgAAAAAAABAAE</span></span></code></pre></div><p>该设置适用于非个性化 HTML，但对于使用 cookie 进行个性化的响应（例如，在登录后），不要忘记同时指定 <code class="language-text">private</code>：</p><div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http">200 OK HTTP/1.1
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">1024</span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-cache, private</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 22 Feb 2022 20:20:20 GMT</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">AAPuIbAOdvAGEETbgAAAAAAABAAE</span></span>
<span class="token header"><span class="token header-name keyword">Set-Cookie</span><span class="token punctuation">:</span> <span class="token header-value">__Host-SID=AHNtAyt3fvJrUL5g5tnGwER; Secure; Path=/; HttpOnly</span></span></code></pre></div><p><code class="language-text">favicon.ico</code>、<code class="language-text">manifest.json</code>、<code class="language-text">.well-known</code> 和无法使用缓存破坏更改 URL 的 API 端点也是如此。</p><p>大多数 Web 内容都可以通过上述两种模式的组合来覆盖。</p><h3 id="有关托管缓存的更多信息" style="position:relative"><a href="#%E6%9C%89%E5%85%B3%E6%89%98%E7%AE%A1%E7%BC%93%E5%AD%98%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF" aria-label="有关托管缓存的更多信息 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有关托管缓存的更多信息</h3><p>使用前面章节描述的方法，子资源可以通过缓存破坏来缓存很长时间，但主资源（  通常是 HTML 文档）不能。</p><p>缓存主要资源很困难，因为仅使用 HTTP 缓存规范中的标准指令，在服务器上更新内容时无法主动删除缓存内容。</p><p>但是，可以通过部署托管缓存（例如 CDN 或 service worker）来实现。</p><p>例如，允许通过 API 或仪表板操作清除缓存的 CDN 将通过存储主要资源并仅在服务器上发生更新时显式清除相关缓存来实现更积极的缓存策略。</p><p>如果 service worker 可以在服务器上发生更新时删除缓存 API 中的内容，它也可以这样做。</p><p>有关更多信息，请参阅 CDN 文档，并查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">service worker 文档</a>。</p><h2 id="参见" style="position:relative"><a href="#%E5%8F%82%E8%A7%81" aria-label="参见 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参见</h2><ul><li><a href="https://datatracker.ietf.org/doc/html/RFC9111">RFC 9111: Hypertext Transfer Protocol (HTTP/1.1): Caching</a></li><li><a href="https://www.mnot.net/cache_docs/">Caching Tutorial - Mark Nottingham</a></li></ul></div></div><style data-emotion="css 4xkoi8">.css-4xkoi8{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}@media (min-width:600px){.css-4xkoi8{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}@media (min-width:900px){.css-4xkoi8{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}@media (min-width:1200px){.css-4xkoi8{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}@media (min-width:1536px){.css-4xkoi8{-webkit-flex-basis:25%;-ms-flex-preferred-size:25%;flex-basis:25%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:25%;}}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-3 css-4xkoi8"><style data-emotion="css 43clin">.css-43clin{list-style:none;margin:0;padding:0;position:relative;padding-top:8px;padding-bottom:8px;width:100%;background-color:#fff;position:-webkit-sticky;position:sticky;overflow:auto;margin-top:16px;top:80px;}</style><ul class="MuiList-root MuiList-padding css-43clin"><style data-emotion="css e3w6lg">.css-e3w6lg{box-sizing:border-box;line-height:48px;list-style:none;color:rgba(0, 0, 0, 0.6);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:500;font-size:0.875rem;padding-left:16px;padding-right:16px;position:-webkit-sticky;position:sticky;top:0;z-index:1;background-color:#fff;}</style><li class="MuiListSubheader-root MuiListSubheader-gutters MuiListSubheader-sticky css-e3w6lg">目录</li><style data-emotion="css 1yo8bqd">.css-1yo8bqd{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:relative;-webkit-text-decoration:none;text-decoration:none;width:100%;box-sizing:border-box;text-align:left;padding-top:8px;padding-bottom:8px;padding-left:16px;padding-right:16px;}.css-1yo8bqd.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-1yo8bqd.Mui-selected{background-color:rgba(25, 118, 210, 0.08);}.css-1yo8bqd.Mui-selected.Mui-focusVisible{background-color:rgba(25, 118, 210, 0.2);}.css-1yo8bqd.Mui-disabled{opacity:0.38;}</style><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#概览"><style data-emotion="css 1tsvksn">.css-1tsvksn{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;min-width:0;margin-top:4px;margin-bottom:4px;}</style><div class="MuiListItemText-root css-1tsvksn"><style data-emotion="css yb0lig">.css-yb0lig{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;display:block;}</style><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">概览</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#不同种类的缓存"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">不同种类的缓存</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#启发式缓存"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">启发式缓存</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#基于-age-的缓存策略"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">基于 age 的缓存策略</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#expires-或-max-age"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">Expires 或 max-age</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#vary-响应"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">Vary 响应</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#验证响应"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">验证响应</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#不使用缓存"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">不使用缓存</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#重新加载和强制重新加载"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">重新加载和强制重新加载</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#删除存储的响应"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">删除存储的响应</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#请求折叠"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">请求折叠</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#常见的缓存模式"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">常见的缓存模式</span></div></a><a class="MuiListItem-root MuiListItem-gutters MuiListItem-padding css-1yo8bqd" href="/blog/http/cache/#参见"><div class="MuiListItemText-root css-1tsvksn"><span class="MuiTypography-root MuiTypography-body1 MuiListItemText-primary css-yb0lig">参见</span></div></a></ul></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/http/cache/";window.___webpackCompilationHash="112f007ead51ed2aa958";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-34167a7a835b29790232.js"],"app":["/app-54782daaa6997e83f31c.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-b91e4ac5871d302841fe.js"],"component---src-templates-article-tsx":["/component---src-templates-article-tsx-08c0f97a1442e4c82ae2.js"]};/*]]>*/</script><script src="/blog/polyfill-34167a7a835b29790232.js" nomodule=""></script><script src="/blog/app-54782daaa6997e83f31c.js" async=""></script><script src="/blog/framework-44df6ec98ae32c3d8ebc.js" async=""></script><script src="/blog/webpack-runtime-0a9db90a7da262af3219.js" async=""></script></body></html>