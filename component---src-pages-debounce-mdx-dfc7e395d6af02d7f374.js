"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[501],{6531:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return i},default:function(){return l}});var o=t(358),u=(t(2983),t(4256)),c=["components"],i={title:"实现一个 debounce 防抖函数",slug:"debounce",description:"实现一个 debounce 防抖函数",tags:["debounce"]},r={_frontmatter:i};function l(e){var n=e.components,t=(0,o.Z)(e,c);return(0,u.kt)("wrapper",Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h2",null,"实现一个 debounce 防抖函数"),(0,u.kt)("h3",null,"什么是 debouce？"),(0,u.kt)("p",null,"翻看 Underscore 的文档，它是这么描述 debounce 的："),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"返回 function 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 wait 毫秒之后. 对于必须在一些输入（多是一些用户操作）停止到达之后执行的行为有帮助。 例如: 渲染一个 Markdown 格式的评论预览, 当窗口停止改变大小之后重新计算布局, 等等.")),(0,u.kt)("h3",null,"基本实现"),(0,u.kt)("p",null,"debounce 本质上，是一个定时器 setTimeout，在 wait 毫秒时间之后，执行传入的函数："),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre"},"function debounce(func, wait, immediate) {\n  let timeout;\n\n  const debounced = function() {\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(func, wait);\n  }\n\n  return debounced;\n}\n")))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-debounce-mdx-dfc7e395d6af02d7f374.js.map